# InterfaceDemo

接口是一种抽象类型，它只定义了成员（方法、属性、事件、索引器）的签名，但不包含任何实现。类或结构体可以通过 “: 接口名” 来实现接口，必须实现接口中定义的所有成员。

可以把接口看作一个“规范清单”，类似于工作岗位的职位要求表。比如岗位说明里写：要会写报告（WriteReport()）；要会开车（Drive()）；要会用电脑（UseComputer()）。但这份清单不会告诉你怎么写报告、怎么开车，怎么做是具体人（类）来决定的。所以接口 = “要求清单 / 契约”，类 = “具体的人去完成这份工作”。

主题：模拟商品物流发货
## 1.多种商品类型+发货策略

- 接口IProduct：定义商品名称、价格、ID、是否已经发货和发货策略
- 实物PhysicialProduct：直接发货到收货人居住地址
- 电子DigitalProduct：直接发货到收货人邮箱地址，并计算发货次数
## 2.价格规则

- 接口IPriceRule：定义计价规则
- 优惠规则：会员折扣、满减、种类折扣（函数）
- 最终：依次会员折扣->种类折扣->满减计算总费用（创建接口的列表依次存储规则方法，一次调用）
# GenericsDemo

泛型是一种参数化类型机制。它允许在定义类、接口、方法、委托时使用类型参数（T、TKey、TValue 等），而不是固定具体的数据类型。

可以把泛型看作“模具上的占位符”。想象在工厂里做杯子模具，不确定要用玻璃、塑料、还是金属，模具上先写个占位符 T。等真正生产时再决定：T = 玻璃 / 塑料 / 金属。好处是一次做模具（写一份代码），以后生产任何材质的杯子都能用（代码复用）。工厂在生产时会检查：你选的材料必须符合要求，比如「必须能耐热」（泛型约束），这样不会出错。所以泛型 = “模具上的占位符”，具体类型 = “真正生产时选用的材料”
# EventDemo